# Pentest Remediation Guidance

Reference for understanding and remediating common penetration test findings.

---

## Understanding Pentest Reports

### Severity Levels

| Severity | CVSS Score | Remediation Timeline | Examples |
|----------|------------|---------------------|----------|
| **Critical** | 9.0 - 10.0 | Immediate (24-48h) | RCE, SQLi with data access, auth bypass |
| **High** | 7.0 - 8.9 | 1-2 weeks | Stored XSS, privilege escalation, IDOR |
| **Medium** | 4.0 - 6.9 | 1 month | Reflected XSS, info disclosure, weak crypto |
| **Low** | 0.1 - 3.9 | 3 months | Missing headers, verbose errors |
| **Informational** | 0.0 | Best effort | Best practice suggestions |

### Common Finding Categories

1. **Authentication & Session** - Login flaws, session management
2. **Authorization** - Access control, privilege issues
3. **Injection** - SQLi, XSS, command injection
4. **Configuration** - Headers, TLS, defaults
5. **Cryptography** - Weak algorithms, key management
6. **Information Disclosure** - Error messages, metadata
7. **Business Logic** - Race conditions, workflow bypass

---

## Critical Findings

### Remote Code Execution (RCE)

**Finding:** Attacker can execute arbitrary code on the server.

**Common causes:**
- Unsafe deserialization (pickle, yaml.load)
- Command injection (os.system, subprocess with shell=True)
- Template injection (Jinja2, etc.)
- File upload leading to code execution

**Remediation:**

```python
# VULNERABLE - Pickle deserialization
data = pickle.loads(user_input)

# FIXED - Use safe alternatives
data = json.loads(user_input)

# VULNERABLE - Command injection
os.system(f"convert {user_file} output.png")

# FIXED - Use subprocess with list args
subprocess.run(["convert", validated_file, "output.png"])

# VULNERABLE - Template injection
template = Template(user_input)

# FIXED - Never use user input as template
template = Template("Hello {{ name }}")
template.render(name=user_input)
```

### SQL Injection with Data Access

**Finding:** Attacker can read/modify database contents.

**Remediation:**

```python
# VULNERABLE
query = f"SELECT * FROM users WHERE id = {user_id}"

# FIXED - Parameterized queries
query = "SELECT * FROM users WHERE id = %s"
cursor.execute(query, (user_id,))

# FIXED - ORM
User.query.filter_by(id=user_id).first()
```

**Verification:** Run sqlmap against the endpoint to confirm fix.

### Authentication Bypass

**Finding:** Attacker can access accounts without proper credentials.

**Common causes:**
- JWT none algorithm accepted
- Password reset token predictable
- Session fixation
- OAuth misconfiguration

**Remediation:**

```python
# VULNERABLE - Accepts 'none' algorithm
payload = jwt.decode(token, options={"verify_signature": False})

# FIXED - Explicit algorithm
payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])

# VULNERABLE - Predictable reset token
token = str(user_id) + str(int(time.time()))

# FIXED - Cryptographically secure token
token = secrets.token_urlsafe(32)
```

---

## High Severity Findings

### Stored XSS

**Finding:** Attacker can inject JavaScript stored in database.

**Remediation:**

```python
# VULNERABLE - Direct output
return f"<div>{user_comment}</div>"

# FIXED - HTML encoding
from markupsafe import escape
return f"<div>{escape(user_comment)}</div>"

# In React (usually safe by default)
# VULNERABLE
<div dangerouslySetInnerHTML={{__html: userContent}} />

# FIXED
<div>{userContent}</div>  # Auto-escaped

# If HTML needed, sanitize
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(userContent)}} />
```

### Insecure Direct Object Reference (IDOR)

**Finding:** User can access other users' resources by changing IDs.

**Remediation:**

```python
# VULNERABLE
@app.get("/api/documents/{doc_id}")
async def get_document(doc_id: int):
    return await db.documents.get(doc_id)

# FIXED - Check ownership
@app.get("/api/documents/{doc_id}")
async def get_document(doc_id: int, user: User = Depends(get_current_user)):
    doc = await db.documents.get(doc_id)
    if doc.owner_id != user.id:
        raise HTTPException(403, "Access denied")
    return doc
```

### Privilege Escalation

**Finding:** Regular user can access admin functions.

**Remediation:**

```python
# VULNERABLE - Client-side only check
@app.post("/api/admin/delete-user")
async def delete_user(user_id: int):
    # No server-side auth check!
    await db.users.delete(user_id)

# FIXED - Server-side authorization
@app.post("/api/admin/delete-user")
async def delete_user(
    user_id: int,
    admin: User = Depends(require_admin)  # Validates admin role
):
    await db.users.delete(user_id)
```

---

## Medium Severity Findings

### Reflected XSS

**Finding:** User input reflected in response without encoding.

**Remediation:**

```python
# VULNERABLE - Error message reflects input
@app.get("/search")
async def search(q: str):
    return f"<p>No results for: {q}</p>"

# FIXED
from markupsafe import escape

@app.get("/search")
async def search(q: str):
    return f"<p>No results for: {escape(q)}</p>"
```

### Missing Security Headers

**Finding:** Response lacks security headers.

**Remediation:**

```python
# Add security headers middleware
@app.middleware("http")
async def add_security_headers(request, call_next):
    response = await call_next(request)

    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    response.headers["Content-Security-Policy"] = "default-src 'self'"
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    response.headers["Permissions-Policy"] = "geolocation=(), microphone=()"

    return response
```

### Weak Password Policy

**Finding:** Application accepts weak passwords.

**Remediation:**

```python
from pydantic import validator
import re

class UserCreate(BaseModel):
    password: str

    @validator("password")
    def password_strength(cls, v):
        if len(v) < 12:
            raise ValueError("Password must be at least 12 characters")
        if not re.search(r"[A-Z]", v):
            raise ValueError("Password must contain uppercase letter")
        if not re.search(r"[a-z]", v):
            raise ValueError("Password must contain lowercase letter")
        if not re.search(r"\d", v):
            raise ValueError("Password must contain digit")
        if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", v):
            raise ValueError("Password must contain special character")
        return v
```

### Information Disclosure

**Finding:** Error messages reveal sensitive information.

**Remediation:**

```python
# VULNERABLE - Stack trace in response
@app.exception_handler(Exception)
async def handler(request, exc):
    return JSONResponse({
        "error": str(exc),
        "traceback": traceback.format_exc()
    }, status_code=500)

# FIXED - Generic error, log details internally
@app.exception_handler(Exception)
async def handler(request, exc):
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse({
        "error": "An internal error occurred",
        "request_id": request.state.request_id
    }, status_code=500)
```

---

## Low Severity Findings

### Missing Rate Limiting

**Remediation:**

```python
from slowapi import Limiter

limiter = Limiter(key_func=get_remote_address)

@app.post("/login")
@limiter.limit("5/minute")
async def login(request: Request, credentials: LoginRequest):
    pass
```

### Cookie Security Flags

**Remediation:**

```python
# VULNERABLE
response.set_cookie("session", token)

# FIXED
response.set_cookie(
    "session",
    token,
    httponly=True,    # Not accessible via JavaScript
    secure=True,      # HTTPS only
    samesite="strict" # CSRF protection
)
```

### Verbose Server Headers

**Remediation:**

```python
# Remove server version disclosure
# In uvicorn
uvicorn.run(app, server_header=False)

# Remove X-Powered-By, Server headers
@app.middleware("http")
async def remove_server_header(request, call_next):
    response = await call_next(request)
    response.headers.pop("server", None)
    response.headers.pop("x-powered-by", None)
    return response
```

---

## Verification Testing

After remediation, verify the fix:

### For XSS
```bash
# Test with common payloads
curl "https://app.com/search?q=<script>alert(1)</script>"
# Response should show encoded: &lt;script&gt;
```

### For SQLi
```bash
# Test with sqlmap
sqlmap -u "https://app.com/api/users?id=1" --batch
# Should report: "all tested parameters do not appear to be injectable"
```

### For Auth Issues
```bash
# Test endpoint without auth
curl -X GET "https://app.com/api/admin/users"
# Should return 401 or 403
```

### For IDOR
```bash
# Test accessing another user's resource
curl -H "Authorization: Bearer user_a_token" \
     "https://app.com/api/documents/user_b_doc_id"
# Should return 403
```

---

## Remediation Workflow

1. **Triage** - Prioritize by severity and exploitability
2. **Reproduce** - Confirm the vulnerability exists
3. **Fix** - Implement remediation
4. **Test** - Verify fix works and doesn't break functionality
5. **Review** - Code review the fix
6. **Deploy** - Push to production
7. **Verify** - Retest in production
8. **Document** - Update remediation tracker

---

## Common Pentest Tools

Understand what pentesters use to find issues:

| Tool | Purpose | What It Finds |
|------|---------|---------------|
| Burp Suite | Web proxy | XSS, SQLi, auth issues |
| sqlmap | SQL injection | SQLi vulnerabilities |
| Nmap | Port scanning | Open ports, services |
| Nikto | Web scanner | Misconfigurations |
| OWASP ZAP | Web scanner | OWASP Top 10 |
| Nuclei | CVE scanner | Known vulnerabilities |
| ffuf/gobuster | Fuzzing | Hidden endpoints |

Use these to verify your own fixes before the retest.
